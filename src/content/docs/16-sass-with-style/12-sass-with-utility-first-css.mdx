---
title: 'Sass with Utility-First CSS'
description: 'How Sass and utility-first CSS coexist, and how to divide responsibilities without overlap.'
sidebar:
  order: 12
  label: 'Sass + Utilities'
draft: false
---

import { LinkButton } from '@astrojs/starlight/components';
import MiniMo from '../../../components/MiniMo.astro';

## Why This Combination Comes Up

In modern projects, Sass and utility-first CSS often appear together.

This can feel redundant at first:

- Sass already generates CSS
- utility classes already encode design decisions

The key is understanding that they solve _different_ problems.

---

## Different Responsibilities

Utility-first CSS focuses on:

- composition at the markup level
- consistent application of spacing, color, and layout
- rapid iteration without writing new selectors

Sass focuses on:

- authoring structure
- data and generation
- compile-time decision making

Used together, Sass supports the system, while utilities express intent in the HTML.

---

## What We Do _Not_ Use Sass For

When using a utility-first approach, Sass is usually not responsible for:

- recreating utility classes
- generating one-to-one replacements for framework utilities
- styling individual components that already compose cleanly with utilities

Duplicating utilities in Sass adds complexity without benefit.

---

## Where Sass Fits Well

Sass works well alongside utilities when it is used to:

- define design tokens
- generate CSS custom properties
- create small, focused abstractions utilities can consume
- organize non-utility styles (resets, base styles, layout primitives)

This keeps responsibilities clear and avoids overlap.

---

## A Practical Pattern

A common pattern is:

1. Define tokens in Sass
2. Generate CSS custom properties
3. Consume those variables from utilities

For example:

```scss
$colors: (
  primary: #3366ff,
  surface: #ffffff,
  text: #111111,
);

:root {
  @each $name, $value in $colors {
    --#{$name}: #{$value};
  }
}
```

Utilities (or custom utilities) can then reference these variables rather than hard-coded values.

---

## Sass Is Not Competing with Utilities

Utility-first CSS is about _usage_.

Sass is about _authoring_.

When those roles are respected, the two tools complement each other instead of competing.

---

## When This Combination Makes Sense

Using Sass with utilities makes sense when:

- the project has shared tokens or themes
- generation or data structures reduce duplication
- runtime flexibility is still required

It makes less sense when Sass is used only to recreate utilities that already exist.

## Adding Tailwind CSS to a Vite project with Sass

We already have a Vite project compiling Sass (SCSS). Now we‚Äôre adding Tailwind on top of that same pipeline.

---

## 1) Install Tailwind + PostCSS deps

From the project root:

```bash
npm install -D tailwindcss postcss autoprefixer
```

---

## 2) Initialize Tailwind + PostCSS config

```bash
npx tailwindcss init -p
```

That generates:

- `tailwind.config.js`
- `postcss.config.js`

Vite will automatically use PostCSS when it sees `postcss.config.js`.

---

## 3) Point Tailwind at your source files

Open `tailwind.config.js` and set `content` so Tailwind can ‚Äúsee‚Äù every place you use utility classes:

```js
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx,vue,svelte,html}'],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

If Tailwind classes aren‚Äôt showing up, this is the first place to look.

---

## 4) Add Tailwind directives to your main Sass file

In your existing Sass entry file (example: `src/styles/main.scss`), put Tailwind at the top:

```scss
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Your Sass can follow */
@use './partials/variables' as *;
@use './partials/mixins' as *;

/* Example: keep your custom styles below Tailwind */
body {
  font-family: system-ui, sans-serif;
}
```

Notes:

- Keep the `@tailwind` directives **before** any Sass that uses Tailwind features like `@apply`.
- You can still use Sass partials/modules as usual.

---

## 5) Make sure Vite imports your SCSS entry

In `src/main.js` (or `src/main.ts`), import your SCSS file:

```js
import './styles/main.scss';
```

If you already import a CSS/SCSS file, just ensure it‚Äôs the one containing the Tailwind directives.

---

## 6) Run it

```bash
npm run dev
```

Then test quickly by dropping a Tailwind class into your markup, e.g. `class="p-6 text-xl"`.

---

## Common gotchas

- **Nothing changes after adding Tailwind:** restart the dev server.
- **Utilities don‚Äôt generate:** your `content` globs are wrong (or your HTML/JS lives somewhere Tailwind isn‚Äôt scanning).
- **`@apply` errors:** make sure Tailwind directives are loaded first, and you‚Äôre not trying to `@apply` arbitrary values that require enabling features/plugins.

---

## Extra Bits & Bytes

<LinkButton
  href="/assets/resources/infographics/sass/12-sass-and-tailwind-together.png"
  target="_blank"
  variant="secondary"
>
  üìò Sass and Tailwind CSS, United - Infographic
</LinkButton>

---

## ‚è≠ Knowing When to Stop

The last skill is judgment.

Next, we‚Äôll look at when Sass genuinely helps a project ‚Äî and when it‚Äôs better to leave it out entirely.
