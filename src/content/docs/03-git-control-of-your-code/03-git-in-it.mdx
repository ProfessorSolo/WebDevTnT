---
title: Initializing a Git Repo
sidebar:
  label: git init
  order: 4
draft: true
---

# Let's Git In It

Weâ€™ve got Git installed. Weâ€™ve configured our name and identity.  
Now itâ€™s time to flip the switch â€” to **Git in it**.

This is where the magic begins: weâ€™ll initialize our first repository, make our first commit, and officially enter the world of version control.

---

## ğŸ§± Step 1: Initialize a Repository

In any folder where weâ€™re about to start a project â€” whether itâ€™s HTML, CSS, JS, or a top-secret side hustle â€” we tell Git:

```bash
git init
```

This simple command turns an ordinary folder into a **Git-powered time machine**.

Behind the scenes, Git creates a hidden directory called `.git` â€” its control room.

```
project-folder/
 â”œâ”€â”€ index.html
 â”œâ”€â”€ styles.css
 â””â”€â”€ .git/        â† Gitâ€™s brain lives here
```

ğŸ’¡ **Professor Soloâ€™s Pro Tip:**  
That `.git` folder holds everything â€” commits, branches, configuration, and history.  
Delete it, and your repo loses its memory. (So, donâ€™t.)

---

## ğŸ§© Step 2: Check Gitâ€™s Status

After initializing, letâ€™s peek at what Git sees:

```bash
git status
```

Weâ€™ll see something like this:

```
On branch main

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
    index.html
    styles.css
```

ğŸ§  **Translation:**  
Git knows files exist, but itâ€™s not tracking them yet â€” theyâ€™re just _untracked_.  
We need to tell Git which ones we care about.

---

## ğŸ“¦ Step 3: Stage Files for Commit

When weâ€™re ready to include files in our next snapshot, we add them to the **staging area**.

```bash
git add index.html
git add styles.css
```

To add _everything_ in the folder:

```bash
git add .
```

âš ï¸ **Caution:**  
Use `git add .` with care â€” it grabs everything that isnâ€™t ignored.  
(Weâ€™ll learn `.gitignore` soon, and it will become our best friend.)

---

## ğŸ§  What Just Happened?

We told Git: â€œWatch these files. I might want to save them soon.â€  
Theyâ€™re not committed yet â€” just staged for inclusion in the next snapshot.

Think of staging like putting your work in a folder labeled _Ready to Turn In_.

---

## ğŸ§® Step 4: Make the First Commit

Once weâ€™re happy with whatâ€™s staged, we take the first snapshot:

```bash
git commit -m "Initial commit â€” project setup"
```

ğŸ’¡ The `-m` flag lets us include a commit message right in the command.

Each commit records:

- What changed
- Who made the change
- When it happened
- Why (our message!)

---

## ğŸ§­ Step 5: Verify the Commit

Now letâ€™s check our work:

```bash
git log --oneline
```

Output might look like this:

```
1e9b312 (HEAD -> main) Initial commit â€” project setup
```

Thatâ€™s our first commit â€” a permanent entry in the projectâ€™s history.

ASCII visualization:

```
HEAD â†’ â—â”€â”€â–¶ main
        â†‘
     Initial commit
```

ğŸ’¡ **Professor Soloâ€™s Pro Tip:**  
Every time we commit, Git moves `HEAD` â€” a pointer that shows where we are in time.  
Itâ€™s like a bookmark for our current place in the story.

---

## ğŸ§­ Step 6: Modify, Stage, Commit Again

Letâ€™s add a new line to `index.html`:

```html
<p>Hello Git!</p>
```

Then run:

```bash
git status
```

Git notices the change.  
We can repeat our favorite loop:

```bash
git add index.html
git commit -m "Add greeting message to home page"
```

And just like that, our project now has a timeline of two commits â€” a tiny but mighty history.

```
HEAD â†’ â—â”€â”€â—â”€â”€â–¶ main
        â†‘
     newest commit
```

---

## âœ… Mission Check: Weâ€™re Officially Git-ing It

By now, we can:

1. Initialize a repository with `git init`
2. Use `git status` to check what Git sees
3. Stage files with `git add`
4. Save changes with `git commit -m "message"`
5. View our commit history with `git log`

---

ğŸ’¡ **Professor Solo says:**

> â€œThe first commit is like the pilot episode.  
> It sets the tone for everything that follows.â€
